package storage

import (
	"context"
	"encoding/json"
	"os"
	"os/exec"
	"path"
	"reflect"
	"strings"
	"testing"
	"time"

	"github.com/baalimago/go_away_boilerplate/pkg/ancli"
	"github.com/baalimago/go_away_boilerplate/pkg/debug"
	"github.com/baalimago/go_away_boilerplate/pkg/testboil"
	"github.com/baalimago/kinoview/internal/model"
)

func Test_store_Setup(t *testing.T) {
	t.Run("successful setup", func(t *testing.T) {
		s := newTestStore(t)

		_, err := s.Setup(context.Background())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
	})

	t.Run("loads items from json, using id as key", func(t *testing.T) {
		s := newTestStore(t)

		key := "an-id"
		want := model.Item{Name: "a", ID: key, Path: path.Join(s.storePath, key)}
		wantBytes, err := json.Marshal(want)
		if err != nil {
			t.Fatalf("failed to marshal want: %v", err)
		}

		jsonPath := path.Join(s.storePath, key)
		if errW := os.WriteFile(jsonPath, wantBytes, 0o644); errW != nil {
			t.Fatalf("failed to create empty store.json: %v", errW)
		}

		_, err = s.Setup(context.Background())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
		s.cacheMu.Lock()
		t.Cleanup(s.cacheMu.Unlock)
		got, exists := s.cache[key]
		if !exists {
			t.Fatal("expected item to exist")
		}

		if !reflect.DeepEqual(want, got) {
			t.Fatalf("expected: %+v, to be: %+v", got, want)
		}
	})

	testboil.ReturnsOnContextCancel(t, func(ctx context.Context) {
		s := newTestStore(t)
		_, err := s.Setup(context.Background())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
	}, time.Millisecond*100)
}

func TestJSONStore_Store(t *testing.T) {
	ancli.Silent = true
	t.Run("store item successfully", func(t *testing.T) {
		s := newTestStore(t)

		_, err := s.Setup(context.Background())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}

		item := model.Item{Name: "sample", ID: "1234"}
		err = s.Store(context.Background(), item)
		if err != nil {
			t.Fatalf("Store failed: %v", err)
		}

		s.cacheMu.Lock()
		got, exists := s.cache[item.ID]
		s.cacheMu.Unlock()
		if !exists {
			t.Fatal("expected item to be stored but it does not exist")
		}
		if !reflect.DeepEqual(item, got) {
			t.Fatalf("expected: %+v, got: %+v", item, got)
		}
	})

	// This test is to ensure that the path of some media is updated while
	// the rest of the data is kept, as this is generated by LLM
	t.Run("update path on item without ID, keep the rest", func(t *testing.T) {
		s := newTestStore(t)
		_, err := s.Setup(context.Background())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
		pre := testboil.CreateTestFile(t, "before")
		post := testboil.CreateTestFile(t, "after")
		t.Cleanup(func() {
			pre.Close()
			post.Close()
		})
		largeIshString := ""
		for range 10 {
			largeIshString += "AABBCCDDEEFFGGAABBCCDDEEFFGGAABBCCDDEEFFGG"
		}
		// Same content in both files, implying it has been moved
		pre.WriteString(largeIshString)
		post.WriteString(largeIshString)
		want := json.RawMessage(`{"This":  "should stay"}`)
		has := model.Item{Name: "with_ID", Path: pre.Name(), Metadata: &want}
		id := generateID(has.Path)
		has.ID = id

		s.cacheMu.Lock()
		s.cache[id] = has
		s.cacheMu.Unlock()

		newItemWithNoID := has
		newItemWithNoID.ID = ""
		newItemWithNoID.Path = post.Name()
		// Test should fail if this is overwritten
		n := json.RawMessage(`{}`)
		newItemWithNoID.Metadata = &n
		err = s.Store(context.Background(), newItemWithNoID)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		s.cacheMu.Lock()
		t.Cleanup(s.cacheMu.Unlock)
		got := s.cache[id].Metadata
		testboil.FailTestIfDiff(t, string(*got), string(want))
	})
}

func Test_streamMkvToMp4(t *testing.T) {
	t.Run("successful mkv to mp4 stream", func(t *testing.T) {
		if _, err := exec.LookPath("ffmpeg"); err != nil {
			t.Skip("ffmpeg binary not found")
		}

		// Prepare test file path
		mkvPath := "mock/Jellyfish_1080_10s_1MB.mkv"
		if _, err := os.Stat(mkvPath); err != nil {
			t.Fatalf("test mkv file missing: %v", err)
		}

		req := mockHTTPRequest("GET", "/test", nil)
		r := req

		rec := newMockResponseWriter()

		streamMkvToMp4(rec, r, mkvPath)

		// Verify headers
		if rec.Header().Get("Content-Type") != "video/mp4" {
			t.Errorf("Content-Type not set: %s", rec.Header().Get("Content-Type"))
		}
		if rec.Header().Get("Accept-Ranges") != "bytes" {
			t.Errorf("Accept-Ranges not set")
		}
		if rec.Header().Get("Cache-Control") != "no-cache" {
			t.Errorf("Cache-Control not set")
		}
		// Output MP4 check (ftyp tag near file start)
		out := rec.buffer
		if len(out) < 12 || string(out[4:8]) != "ftyp" {
			t.Errorf("output not mp4 format")
		}
		if rec.statusCode != 200 && rec.statusCode != 0 {
			t.Errorf("unexpected http status: %d", rec.statusCode)
		}
	})

	t.Run("missing ffmpeg returns error", func(t *testing.T) {
		origLookPath := ffmpegLookPath
		ffmpegLookPath = "non-existent"
		t.Cleanup(func() {
			ffmpegLookPath = origLookPath
		})
		req := mockHTTPRequest("GET", "/test", nil)
		rec := newMockResponseWriter()
		streamMkvToMp4(rec, req, "mock/Jellyfish_1080_10s_1MB.mkv")
		if rec.statusCode != 500 {
			t.Errorf("expected 500 when ffmpeg is missing")
		}
		if !strings.Contains(string(rec.buffer), "ffmpeg must be installed") {
			t.Errorf("missing ffmpeg error response not found")
		}
	})

	t.Run("bad mkv path triggers error", func(t *testing.T) {
		req := mockHTTPRequest("GET", "/test", nil)
		rec := newMockResponseWriter()
		streamMkvToMp4(rec, req, "mock/doesnotexist.mkv")
		if rec.statusCode != 500 {
			t.Errorf("expected http status 500 for bad mkv input")
		}
	})

	t.Run("context cancel simulates disconnect", func(t *testing.T) {
		mkvPath := "mock/Jellyfish_1080_10s_1MB.mkv"
		req := mockHTTPRequest("GET", "/test", nil)
		ctx, cancel := context.WithCancel(req.Context())
		req = req.WithContext(ctx)
		rec := newMockResponseWriter()
		done := make(chan struct{})
		go func() {
			streamMkvToMp4(rec, req, mkvPath)
			close(done)
		}()
		cancel()
		select {
		case <-done:
		case <-time.After(time.Second):
			t.Errorf("timed out waiting for disconnect simulation")
		}
	})
}

func Test_Stream_store_ffmpegSubsUtil_extract(t *testing.T) {
	t.Run("extract subs if possible", func(t *testing.T) {
		subsUtil := ffmpegSubsUtil{}
		given := model.Item{
			ID:   "some_ID",
			Path: "./mock/Jellyfish_with_subs.mkv",
		}
		gotFile, err := subsUtil.extract(given, "1")
		if err != nil {
			t.Fatalf("failed to extract: %v", err)
		}

		gotData, err := os.ReadFile(gotFile)
		if err != nil {
			t.Fatalf("failed to read gotFile: %v", err)
		}
		// Subtitle line which appears in mock video
		testboil.AssertStringContains(t, string(gotData), "Pay close attention to each step.")
	})

	t.Run("it should error if ffmpeg is not installed", func(t *testing.T) {
		subsUtil := &ffmpegSubsUtil{}
		origPath := os.Getenv("PATH")
		defer os.Setenv("PATH", origPath)
		os.Setenv("PATH", "/nonexistent")
		item := model.Item{ID: "no-ffmpeg", Path: "/tmp/doesnotmatter.mkv"}
		_, err := subsUtil.extract(item, "0")
		if err == nil {
			t.Fatal("expected error when ffprobe unavailable, got nil")
		}
	})
}

func Test_Stream_store_ffmpegSubsUtil_find(t *testing.T) {
	ancli.Silent = true
	t.Run("find uses mediaCache hit", func(t *testing.T) {
		wantIdx := 404
		util := &ffmpegSubsUtil{
			mediaCache: map[string]model.MediaInfo{
				"cache-id": {Streams: []model.Stream{{Index: wantIdx}}},
			},
		}
		item := model.Item{ID: "cache-id", Path: "/tmp/some.mkv"}
		info, err := util.find(item)
		if err != nil {
			t.Fatalf("expected nil error, got %v", err)
		}
		if len(info.Streams) < 1 || info.Streams[0].Index != wantIdx {
			t.Fatalf("unexpected info: %+v", info)
		}
	})

	t.Run("find returns error when ffprobe/ffmpeg unavailable", func(t *testing.T) {
		util := &ffmpegSubsUtil{mediaCache: map[string]model.MediaInfo{}}
		origPath := os.Getenv("PATH")
		defer os.Setenv("PATH", origPath)
		os.Setenv("PATH", "/nonexistent")
		item := model.Item{ID: "missing-ff", Path: "/tmp/irrelevant.mkv"}
		_, err := util.find(item)
		if err == nil {
			t.Fatal("expected error when ffmpeg is unavailable, got nil")
		}
	})

	t.Run("find returns error for invalid input", func(t *testing.T) {
		util := &ffmpegSubsUtil{mediaCache: map[string]model.MediaInfo{}}
		item := model.Item{ID: "bogus", Path: "/path/does/not/exist.mkv"}
		_, err := util.find(item)
		if err == nil {
			t.Fatal("expected error for invalid input, got nil")
		}
	})

	t.Run("find caches on successful find", func(t *testing.T) {
		util := &ffmpegSubsUtil{
			mediaCache: map[string]model.MediaInfo{},
		}
		// Use a known good file with ffprobe available in path
		item := model.Item{ID: "some-unique-id", Path: "./mock/Jellyfish_with_subs.mkv"}
		_, err := util.find(item)
		if err != nil {
			t.Fatalf("unexpected error calling find: %v", err)
		}
		// Should set cache for this ID
		if _, ok := util.mediaCache[item.ID]; !ok {
			t.Fatalf("expected find to cache result for %s", item.ID)
		}
	})
}

func Test_Stream_store_ffmpegSubsUtil_cache(t *testing.T) {
	t.Run("it should return item on media cache hit", func(t *testing.T) {
		wantIdx := 1337
		// Setup ffmpegSubsUtil with mock caches
		util := &ffmpegSubsUtil{
			mediaCache: map[string]model.MediaInfo{
				"id-abc": {Streams: []model.Stream{
					{
						Index: wantIdx,
					},
				}},
			},
			subsCache: map[string]string{
				"id-xyz": "/tmp/mocksubs.vtt",
			},
		}

		item := model.Item{ID: "id-abc", Path: "/tmp/mockfile.mkv"}
		// Should hit mediaCache and return without error
		info, err := util.find(item)
		if err != nil {
			t.Fatalf("expected nil error, got %v", err)
		}
		if info.Streams[0].Index != wantIdx {
			t.Fatalf("unexpected info from mediaCache: %+v", info)
		}

		item.ID = "id-xyz"
		got, err := util.extract(item, "0")
		if err != nil {
			t.Fatalf("expected nil err from extract cache, got %v", err)
		}
		if got != "/tmp/mocksubs.vtt" {
			t.Fatalf("unexpected path from subsCache: %s", got)
		}
	})

	t.Run("error on ffmpeg error (not panic)", func(t *testing.T) {
		util := &ffmpegSubsUtil{
			mediaCache: map[string]model.MediaInfo{},
			subsCache:  map[string]string{},
		}

		item := model.Item{ID: "nohit-" + randString(6), Path: os.DevNull}
		// Funky streamIndex but ffmpeg will fail, so expect error not panics
		_, err := util.extract(item, "0")
		if err == nil {
			t.Fatalf("expected error due to ffmpeg fail")
		}
	})

	t.Run("eventually adds metadata when storing new file", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))
		want := `{"some": "metadata"}`
		s.classifier = &mockClassifier{
			SetupFunc: func(ctx context.Context) error { return nil },
			ClassifyFunc: func(ctx context.Context, i model.Item) (model.Item, error) {
				if i.Metadata == nil {
					r := json.RawMessage(want)
					i.Metadata = &r
				}
				return i, nil
			},
		}
		testCtx, testCtxCancel := context.WithTimeout(context.Background(), time.Millisecond*100)
		t.Cleanup(testCtxCancel)
		storeErrors, err := s.Setup(testCtx)
		s.Start(testCtx)
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
		item := model.Item{Name: "media", ID: "meta1", MIMEType: "video"}
		err = s.Store(context.Background(), item)
		if err != nil {
			t.Fatalf("Store failed: %v", err)
		}

		select {
		case <-time.After(time.Millisecond * 50):
		case err := <-storeErrors:
			t.Fatalf("expected no errors, got: %v", err)
		}
		s.cacheMu.Lock()
		t.Cleanup(s.cacheMu.Unlock)
		got, exist := s.cache[item.ID]
		if !exist {
			t.Fatal("expected item to exist in store")
		}
		gotMetadata := string(*got.Metadata)
		if gotMetadata != want {
			t.Errorf("expected metadata to be set, got: %v", gotMetadata)
		}
	})

	t.Run("existing file metadata is not regenerated or overwritten", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))
		s.classifier = &mockClassifier{
			SetupFunc: func(ctx context.Context) error { return nil },
			ClassifyFunc: func(ctx context.Context, i model.Item) (model.Item, error) {
				r := json.RawMessage(`{"initial":"metadata"}`)
				i.Metadata = &r
				return i, nil
			},
		}
		ctx, ctxCancel := context.WithTimeout(context.Background(), time.Millisecond*100)
		t.Cleanup(ctxCancel)
		_, err := s.Setup(ctx)
		s.Start(ctx)
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
		item := model.Item{Name: "media2", ID: "meta2", MIMEType: "video"}
		err = s.Store(context.Background(), item)
		if err != nil {
			t.Fatalf("Store failed: %v", err)
		}

		time.Sleep(time.Millisecond * 100)
		s.cacheMu.Lock()
		original := s.cache[item.ID]
		s.cacheMu.Unlock()
		originalMeta := string(*original.Metadata)
		s.classifier = &mockClassifier{
			SetupFunc: func(ctx context.Context) error { return nil },
			ClassifyFunc: func(ctx context.Context, i model.Item) (model.Item, error) {
				r := json.RawMessage(`{"new":"metadata"}`)
				i.Metadata = &r
				return i, nil
			},
		}
		err = s.Store(context.Background(), item)
		if err != nil {
			t.Fatalf("Store failed on second call: %v", err)
		}
		time.Sleep(time.Millisecond * 100)
		s.cacheMu.Lock()
		t.Cleanup(s.cacheMu.Unlock)
		got := s.cache[item.ID]
		gotMeta := string(*got.Metadata)
		if gotMeta != originalMeta {
			t.Errorf("metadata should not be overwritten: got %v, want %v", gotMeta, originalMeta)
		}
	})
}

func Test_newJSONStore_options(t *testing.T) {
	t.Run("options pattern should work", func(t *testing.T) {
		mockFinder := &mockSubtitleStreamFinder{}
		mockExtractor := &mockSubtitleStreamExtractor{}
		mockClassifier := &mockClassifier{}

		s := NewStore(
			WithStorePath(t.TempDir()),
			WithSubtitleStreamFinder(mockFinder),
			WithSubtitleStreamExtractor(mockExtractor),
			WithClassifier(mockClassifier),
		)

		if s.subStreamFinder != mockFinder {
			t.Fatal("subtitle stream finder should be the mock finder")
		}

		if s.subStreamExtractor != mockExtractor {
			t.Fatal("subtitle stream extractor should be the mock extractor")
		}

		if s.classifier != mockClassifier {
			t.Fatal("classifier should be the mock classifier")
		}
	})
}

func Test_store_Store(t *testing.T) {
	t.Run("store item updates cache", func(t *testing.T) {
		s := newTestStore(t)

		_, err := s.Setup(context.Background())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}

		item := model.Item{Name: "test-name", ID: "test-id"}
		err = s.store(item)
		if err != nil {
			t.Fatalf("Store failed: %v", err)
		}

		s.cacheMu.Lock()
		got, exists := s.cache[item.ID]
		s.cacheMu.Unlock()
		if !exists {
			t.Fatal("expected item to be in cache but it is not")
		}
		if !reflect.DeepEqual(item, got) {
			t.Fatalf("expected: %+v, got: %+v", item, got)
		}
	})

	t.Run("store updates metadata correctly", func(t *testing.T) {
		s := newTestStore(t)

		// Using the store function
		existingItem := model.Item{ID: "meta-id", Name: "old-name"}
		updatedItem := model.Item{ID: "meta-id", Name: "new-name"}

		s.cacheMu.Lock()
		s.cache[existingItem.ID] = existingItem
		s.cacheMu.Unlock()

		err := s.store(updatedItem)
		if err != nil {
			t.Fatalf("Store failed: %v", err)
		}

		s.cacheMu.Lock()
		got := s.cache[existingItem.ID]
		s.cacheMu.Unlock()

		if got.Name != "new-name" {
			t.Fatalf("expected name to be updated to 'new-name', but got %v", got.Name)
		}
	})

	t.Run("writes item to cache and file", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))
		if err := os.MkdirAll(dir, 0o755); err != nil {
			t.Fatalf("mkdir: %v", err)
		}
		item := model.Item{ID: "a1", Name: "n"}
		if err := s.store(item); err != nil {
			t.Fatalf("store: %v", err)
		}
		s.cacheMu.RLock()
		got, ok := s.cache["a1"]
		s.cacheMu.RUnlock()
		if !ok {
			t.Fatal("cache miss for a1")
		}
		if !reflect.DeepEqual(item, got) {
			t.Fatalf("want %+v got %+v", item, got)
		}
		p := path.Join(dir, "a1")
		if _, err := os.Stat(p); err != nil {
			t.Fatalf("stat: %v", err)
		}
		b, err := os.ReadFile(p)
		if err != nil {
			t.Fatalf("read: %v", err)
		}
		var onDisk model.Item
		if err := json.Unmarshal(b, &onDisk); err != nil {
			t.Fatalf("unmarshal: %v", err)
		}
		if !reflect.DeepEqual(item, onDisk) {
			t.Fatalf("want %+v got %+v, gotjson: %v", item, onDisk, debug.IndentedJsonFmt(onDisk))
		}
	})

	t.Run("overwrites existing item and persists new data", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))
		if err := os.MkdirAll(dir, 0o755); err != nil {
			t.Fatalf("mkdir: %v", err)
		}
		i1 := model.Item{ID: "a1", Name: "old"}
		i2 := model.Item{ID: "a1", Name: "new"}
		if err := s.store(i1); err != nil {
			t.Fatalf("store i1: %v", err)
		}
		if err := s.store(i2); err != nil {
			t.Fatalf("store i2: %v", err)
		}
		s.cacheMu.RLock()
		got := s.cache["a1"]
		s.cacheMu.RUnlock()
		if got.Name != "new" {
			t.Fatalf("cache name = %q", got.Name)
		}
		p := path.Join(dir, "a1")
		b, err := os.ReadFile(p)
		if err != nil {
			t.Fatalf("read: %v", err)
		}
		var onDisk model.Item
		if err := json.Unmarshal(b, &onDisk); err != nil {
			t.Fatalf("unmarshal: %v", err)
		}
		if onDisk.Name != "new" {
			t.Fatalf("disk name = %q", onDisk.Name)
		}
	})

	t.Run("truncates file on overwrite", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))
		if err := os.MkdirAll(dir, 0o755); err != nil {
			t.Fatalf("mkdir: %v", err)
		}
		big := strings.Repeat("X", 2048)
		if err := s.store(model.Item{ID: "a1", Name: big}); err != nil {
			t.Fatalf("store big: %v", err)
		}
		if err := s.store(model.Item{ID: "a1", Name: "s"}); err != nil {
			t.Fatalf("store small: %v", err)
		}
		p := path.Join(dir, "a1")
		b, err := os.ReadFile(p)
		if err != nil {
			t.Fatalf("read: %v", err)
		}
		if strings.Contains(string(b), big) {
			t.Fatal("file not truncated on overwrite")
		}
	})

	t.Run("sets file mode to 0644", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))
		if err := os.MkdirAll(dir, 0o755); err != nil {
			t.Fatalf("mkdir: %v", err)
		}
		if err := s.store(model.Item{ID: "a1"}); err != nil {
			t.Fatalf("store: %v", err)
		}
		p := path.Join(dir, "a1")
		fi, err := os.Stat(p)
		if err != nil {
			t.Fatalf("stat: %v", err)
		}
		if fi.Mode().Perm() != 0o644 {
			t.Fatalf("perm = %v", fi.Mode().Perm())
		}
	})

	t.Run("errors when storePath dir missing", func(t *testing.T) {
		dir := t.TempDir()
		if err := os.RemoveAll(dir); err != nil {
			t.Fatalf("rm: %v", err)
		}
		s := NewStore(WithStorePath(dir))
		err := s.store(model.Item{ID: "a1"})
		if err == nil {
			t.Fatal("expected error")
		}
		if !strings.Contains(err.Error(), "failed to open store") {
			t.Fatalf("err = %v", err)
		}
	})

	t.Run("errors when storePath is a file (ENOTDIR)", func(t *testing.T) {
		f, err := os.CreateTemp(t.TempDir(), "pfx")
		if err != nil {
			t.Fatalf("tmpfile: %v", err)
		}
		defer f.Close()
		s := NewStore(WithStorePath(f.Name()))
		if err := s.store(model.Item{ID: "a1"}); err == nil {
			t.Fatal("expected error")
		}
	})

	t.Run("errors when storePath is read-only", func(t *testing.T) {
		dir := t.TempDir()
		if err := os.Chmod(dir, 0o555); err != nil {
			t.Fatalf("chmod: %v", err)
		}
		s := NewStore(WithStorePath(dir))
		if err := s.store(model.Item{ID: "a1"}); err == nil {
			t.Fatal("expected error")
		}
	})

	t.Run("concurrent stores are safe and complete", func(t *testing.T) {
		ancli.Silent = true
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))
		if err := os.MkdirAll(dir, 0o755); err != nil {
			t.Fatalf("mkdir: %v", err)
		}
		N := 20
		done := make(chan struct{}, N)
		ids := make([]string, N)
		for i := 0; i < N; i++ {
			ids[i] = "id-" + randString(8)
		}
		for _, id := range ids {
			go func(id string) {
				_ = s.store(model.Item{ID: id})
				done <- struct{}{}
			}(id)
		}
		for i := 0; i < N; i++ {
			<-done
		}
		s.cacheMu.RLock()
		l := len(s.cache)
		s.cacheMu.RUnlock()
		if l != N {
			t.Fatalf("cache len = %d want %d", l, N)
		}
		for _, id := range ids {
			p := path.Join(dir, id)
			if _, err := os.Stat(p); err != nil {
				t.Fatalf("stat %s: %v", id, err)
			}
		}
	})

	t.Run("idempotent on same item", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))
		if err := os.MkdirAll(dir, 0o755); err != nil {
			t.Fatalf("mkdir: %v", err)
		}
		item := model.Item{ID: "same", Name: "n"}
		if err := s.store(item); err != nil {
			t.Fatalf("store1: %v", err)
		}
		if err := s.store(item); err != nil {
			t.Fatalf("store2: %v", err)
		}
		p := path.Join(dir, "same")
		b, err := os.ReadFile(p)
		if err != nil {
			t.Fatalf("read: %v", err)
		}
		var onDisk model.Item
		if err := json.Unmarshal(b, &onDisk); err != nil {
			t.Fatalf("unmarshal: %v", err)
		}
		if !reflect.DeepEqual(item, onDisk) {
			t.Fatalf("want %+v got %+v", item, onDisk)
		}
	})
}

func Test_loadPersistedItems(t *testing.T) {
	t.Run("loads valid item into cache", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))

		uf, err := os.CreateTemp(dir, "u")
		if err != nil {
			t.Fatalf("tmp file: %v", err)
		}
		defer uf.Close()

		it := model.Item{
			ID:   "id1",
			Name: "n",
			Path: uf.Name(),
		}
		b, err := json.Marshal(it)
		if err != nil {
			t.Fatalf("marshal: %v", err)
		}
		idx := path.Join(dir, "idx1")
		if err := os.WriteFile(idx, b, 0o644); err != nil {
			t.Fatalf("write: %v", err)
		}

		if err := s.loadPersistedItems(dir); err != nil {
			t.Fatalf("load: %v", err)
		}

		s.cacheMu.RLock()
		_, ok := s.cache["id1"]
		s.cacheMu.RUnlock()
		if !ok {
			t.Fatal("expected cache hit for id1")
		}
	})

	t.Run("ignores directories in store dir", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))

		if err := os.Mkdir(path.Join(dir, "sub"), 0o755); err != nil {
			t.Fatalf("mkdir: %v", err)
		}

		if err := s.loadPersistedItems(dir); err != nil {
			t.Fatalf("load: %v", err)
		}
	})

	t.Run("skips invalid json files", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))

		idx := path.Join(dir, "bad")
		if err := os.WriteFile(idx, []byte("{notjson"), 0o644); err != nil {
			t.Fatalf("write: %v", err)
		}

		if err := s.loadPersistedItems(dir); err != nil {
			t.Fatalf("load: %v", err)
		}

		s.cacheMu.RLock()
		l := len(s.cache)
		s.cacheMu.RUnlock()
		if l != 0 {
			t.Fatalf("cache len = %d want 0", l)
		}
	})

	t.Run("removes index when underlying missing", func(t *testing.T) {
		dir := t.TempDir()
		s := NewStore(WithStorePath(dir))

		it := model.Item{
			ID:   "gone",
			Name: "n",
			Path: path.Join(dir, "nope"),
		}
		b, err := json.Marshal(it)
		if err != nil {
			t.Fatalf("marshal: %v", err)
		}
		idx := path.Join(dir, "idx-gone")
		if err := os.WriteFile(idx, b, 0o644); err != nil {
			t.Fatalf("write: %v", err)
		}

		if err := s.loadPersistedItems(dir); err != nil {
			t.Fatalf("load: %v", err)
		}

		if _, err := os.Stat(idx); !os.IsNotExist(err) {
			t.Fatalf("index file not removed")
		}
		s.cacheMu.RLock()
		_, ok := s.cache["gone"]
		s.cacheMu.RUnlock()
		if ok {
			t.Fatal("should not cache missing underlying")
		}
	})

	t.Run("errors when directory cannot be read", func(t *testing.T) {
		s := NewStore()
		bad := path.Join(t.TempDir(), "missing")
		if err := s.loadPersistedItems(bad); err == nil {
			t.Fatal("expected error on ReadDir")
		}
	})
}
