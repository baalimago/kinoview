package media

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"os/exec"
	"path"
	"reflect"
	"strings"
	"testing"
	"time"

	"github.com/baalimago/go_away_boilerplate/pkg/testboil"
)

func mockHTTPRequest(method, target string, body io.Reader) *http.Request {
	req := httptest.NewRequest(method, target, body)
	return req
}

type mockResponseWriter struct {
	header     http.Header
	statusCode int
	buffer     []byte
}

func newMockResponseWriter() *mockResponseWriter {
	return &mockResponseWriter{header: make(http.Header)}
}

func (m *mockResponseWriter) Header() http.Header {
	return m.header
}

func (m *mockResponseWriter) Write(b []byte) (int, error) {
	m.buffer = append(m.buffer, b...)
	return len(b), nil
}

func (m *mockResponseWriter) WriteHeader(statusCode int) {
	m.statusCode = statusCode
}

func Test_jsonStore_Setup(t *testing.T) {
	t.Run("successful setup", func(t *testing.T) {
		s := newJSONStore()
		tmpDir := t.TempDir()

		jsonPath := path.Join(tmpDir, "store.json")
		if err := os.WriteFile(jsonPath, []byte("[]"), 0o644); err != nil {
			t.Fatalf("failed to create empty store.json: %v", err)
		}

		err := s.Setup(context.Background(), tmpDir)
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
	})

	t.Run("adds store.json if not exist", func(t *testing.T) {
		s := newJSONStore()
		tmpDir := t.TempDir()
		jsonPath := path.Join(tmpDir, "store.json")

		// Ensure store.json does not exist before Setup
		if _, err := os.Stat(jsonPath); !os.IsNotExist(err) {
			t.Fatalf("store.json already exists before test")
		}

		err := s.Setup(context.Background(), tmpDir)
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}

		// Now store.json should exist
		if _, err := os.Stat(jsonPath); err != nil {
			t.Fatalf("store.json not created by Setup: %v", err)
		}
	})

	t.Run("loads items from json, using id as key", func(t *testing.T) {
		s := newJSONStore()
		tmpDir := t.TempDir()

		key := "an-id"
		want := Item{Name: "a", ID: key}
		wantList := []Item{want}
		wantBytes, err := json.Marshal(wantList)
		if err != nil {
			t.Fatalf("failed to marshal want: %v", err)
		}

		jsonPath := path.Join(tmpDir, "store.json")
		if errW := os.WriteFile(jsonPath, wantBytes, 0o644); errW != nil {
			t.Fatalf("failed to create empty store.json: %v", errW)
		}

		err = s.Setup(context.Background(), tmpDir)
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
		got, exists := s.cache[key]
		if !exists {
			t.Fatal("expected item to exist")
		}

		if !reflect.DeepEqual(want, got) {
			t.Fatalf("expected: %+v, to be: %+v", got, want)
		}
	})

	testboil.ReturnsOnContextCancel(t, func(ctx context.Context) {
		s := newJSONStore()
		err := s.Setup(context.Background(), t.TempDir())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
	}, time.Millisecond*100)
}

func Test_jsonStore_Store(t *testing.T) {
	t.Run("store item successfully", func(t *testing.T) {
		s := newJSONStore()

		err := s.Setup(context.Background(), t.TempDir())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}

		item := Item{Name: "sample", ID: "1234"}
		err = s.Store(item)
		if err != nil {
			t.Fatalf("Store failed: %v", err)
		}

		got, exists := s.cache[item.ID]
		if !exists {
			t.Fatal("expected item to be stored but it does not exist")
		}
		if !reflect.DeepEqual(item, got) {
			t.Fatalf("expected: %+v, got: %+v", item, got)
		}
	})

	// This test is to ensure that the path of some media is updated while
	// the rest of the data is kept, as this is generated by LLM
	t.Run("update path on item without ID, keep the rest", func(t *testing.T) {
		s := newJSONStore()
		err := s.Setup(context.Background(), t.TempDir())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
		pre := testboil.CreateTestFile(t, "before")
		post := testboil.CreateTestFile(t, "after")
		t.Cleanup(func() {
			pre.Close()
			post.Close()
		})
		largeIshString := ""
		for range 10 {
			largeIshString += "AABBCCDDEEFFGGAABBCCDDEEFFGGAABBCCDDEEFFGG"
		}
		// Same content in both files, implying it has been moved
		pre.WriteString(largeIshString)
		post.WriteString(largeIshString)
		want := "This should stay"
		has := Item{Name: "with_ID", Path: pre.Name(), Metadata: want}
		id := generateID(has)
		has.ID = id
		s.cache[id] = has

		newItemWithNoID := has
		newItemWithNoID.ID = ""
		newItemWithNoID.Path = post.Name()
		// Test should fail if this is overwritten
		newItemWithNoID.Metadata = ""
		err = s.Store(newItemWithNoID)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		got := s.cache[id].Metadata.(string)
		testboil.FailTestIfDiff(t, got, want)
	})
}

func Test_streamMkvToMp4(t *testing.T) {
	t.Run("successful mkv to mp4 stream", func(t *testing.T) {
		if _, err := exec.LookPath("ffmpeg"); err != nil {
			t.Skip("ffmpeg binary not found")
		}

		// Prepare test file path
		mkvPath := "mock/Jellyfish_1080_10s_1MB.mkv"
		if _, err := os.Stat(mkvPath); err != nil {
			t.Fatalf("test mkv file missing: %v", err)
		}

		req := mockHTTPRequest("GET", "/test", nil)
		r := req

		rec := newMockResponseWriter()

		streamMkvToMp4(rec, r, mkvPath)

		// Verify headers
		if rec.Header().Get("Content-Type") != "video/mp4" {
			t.Errorf("Content-Type not set: %s", rec.Header().Get("Content-Type"))
		}
		if rec.Header().Get("Accept-Ranges") != "bytes" {
			t.Errorf("Accept-Ranges not set")
		}
		if rec.Header().Get("Cache-Control") != "no-cache" {
			t.Errorf("Cache-Control not set")
		}
		// Output MP4 check (ftyp tag near file start)
		out := rec.buffer
		if len(out) < 12 || string(out[4:8]) != "ftyp" {
			t.Errorf("output not mp4 format")
		}
		if rec.statusCode != 200 && rec.statusCode != 0 {
			t.Errorf("unexpected http status: %d", rec.statusCode)
		}
	})

	t.Run("missing ffmpeg returns error", func(t *testing.T) {
		origLookPath := ffmpegLookPath
		ffmpegLookPath = "non-existent"
		t.Cleanup(func() {
			ffmpegLookPath = origLookPath
		})
		req := mockHTTPRequest("GET", "/test", nil)
		rec := newMockResponseWriter()
		streamMkvToMp4(rec, req, "mock/Jellyfish_1080_10s_1MB.mkv")
		if rec.statusCode != 500 {
			t.Errorf("expected 500 when ffmpeg is missing")
		}
		if !strings.Contains(string(rec.buffer), "ffmpeg must be installed") {
			t.Errorf("missing ffmpeg error response not found")
		}
	})

	t.Run("bad mkv path triggers error", func(t *testing.T) {
		req := mockHTTPRequest("GET", "/test", nil)
		rec := newMockResponseWriter()
		streamMkvToMp4(rec, req, "mock/doesnotexist.mkv")
		if rec.statusCode != 500 {
			t.Errorf("expected http status 500 for bad mkv input")
		}
	})

	t.Run("context cancel simulates disconnect", func(t *testing.T) {
		mkvPath := "mock/Jellyfish_1080_10s_1MB.mkv"
		req := mockHTTPRequest("GET", "/test", nil)
		ctx, cancel := context.WithCancel(req.Context())
		req = req.WithContext(ctx)
		rec := newMockResponseWriter()
		done := make(chan struct{})
		go func() {
			streamMkvToMp4(rec, req, mkvPath)
			close(done)
		}()
		cancel()
		select {
		case <-done:
		case <-time.After(time.Second):
			t.Errorf("timed out waiting for disconnect simulation")
		}
	})
}

func Test_jsonStore_ListHandlerFunc(t *testing.T) {
	jStore := &jsonStore{
		cache: map[string]Item{
			"1": {ID: "1", Name: "foo"},
			"2": {ID: "2", Name: "bar"},
		},
	}

	t.Run("returns all items as JSON", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rr := httptest.NewRecorder()

		handler := jStore.ListHandlerFunc()
		handler.ServeHTTP(rr, req)

		if ct := rr.Header().Get("Content-Type"); ct != "application/json" {
			t.Errorf("got Content-Type %q, want application/json", ct)
		}
		var items []Item
		if err := json.NewDecoder(rr.Body).Decode(&items); err != nil {
			t.Fatalf("failed decoding response: %v", err)
		}
		if len(items) != 2 {
			t.Errorf("expected 2 items, got %d", len(items))
		}
	})

	t.Run("cache nil triggers error", func(t *testing.T) {
		js := &jsonStore{}
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rr := httptest.NewRecorder()
		handler := js.ListHandlerFunc()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusInternalServerError {
			t.Errorf("expected internal error on nil cache")
		}
		if !strings.Contains(rr.Body.String(), "store not initialized") {
			t.Errorf("error message not reported")
		}
	})
}

func Test_jsonStore_ItemHandlerFunc(t *testing.T) {
	js := &jsonStore{}
	handler := js.ItemHandlerFunc()

	t.Run("cache nil triggers not found", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/item/1", nil)
		req.SetPathValue("id", "1")
		rr := httptest.NewRecorder()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusNotFound &&
			rr.Result().StatusCode != http.StatusInternalServerError {
			t.Errorf("expected 404 or 500 on nil cache")
		}
	})

	t.Run("missing id returns bad request", func(t *testing.T) {
		js.cache = map[string]Item{}
		req := httptest.NewRequest(http.MethodGet, "/item", nil)
		rr := httptest.NewRecorder()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusBadRequest {
			t.Errorf("want 400, got %d", rr.Result().StatusCode)
		}
	})

	t.Run("unknown id returns 404", func(t *testing.T) {
		js.cache = map[string]Item{}
		req := httptest.NewRequest(http.MethodGet, "/item/xyz", nil)
		req.SetPathValue("id", "xyz")
		rr := httptest.NewRecorder()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusNotFound {
			t.Errorf("want 404, got %d", rr.Result().StatusCode)
		}
	})

	t.Run("known id, file not found", func(t *testing.T) {
		js.cache = map[string]Item{"x": {Path: "no/such/file", MIMEType: "image/png", Name: "img.png"}}
		req := httptest.NewRequest(http.MethodGet, "/item/x", nil)
		req.SetPathValue("id", "x")
		rr := httptest.NewRecorder()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusNotFound {
			t.Errorf("want 404 for missing file, got %d", rr.Result().StatusCode)
		}
	})

	t.Run("exists in cache, path not found", func(t *testing.T) {
		s := newJSONStore()
		tmpDir := t.TempDir()
		err := s.Setup(context.Background(), tmpDir)
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
		item := Item{
			Name:     "cacheonly",
			ID:       "cache-test-id",
			Path:     path.Join(tmpDir, "not-a-real-file.txt"),
			MIMEType: "text/plain",
		}
		s.cache[item.ID] = item

		req := mockHTTPRequest("GET", "/item/"+item.ID, nil)
		req.SetPathValue("id", item.ID)

		rec := newMockResponseWriter()
		handler := s.ItemHandlerFunc()
		handler(rec, req)
		if rec.statusCode != http.StatusNotFound {
			t.Fatalf("Expected status 404, got %d", rec.statusCode)
		}
		if !strings.Contains(string(rec.buffer), "media not found") {
			t.Errorf("Expected error response, got: %s", rec.buffer)
		}
	})
}
