package media

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"os/exec"
	"path"
	"reflect"
	"strings"
	"testing"
	"time"

	"github.com/baalimago/go_away_boilerplate/pkg/testboil"
	"github.com/baalimago/kinoview/internal/model"
)

func mockHTTPRequest(method, target string, body io.Reader) *http.Request {
	req := httptest.NewRequest(method, target, body)
	return req
}

type mockResponseWriter struct {
	header     http.Header
	statusCode int
	buffer     []byte
}

func newMockResponseWriter() *mockResponseWriter {
	return &mockResponseWriter{header: make(http.Header)}
}

func (m *mockResponseWriter) Header() http.Header {
	return m.header
}

func (m *mockResponseWriter) Write(b []byte) (int, error) {
	m.buffer = append(m.buffer, b...)
	return len(b), nil
}

func (m *mockResponseWriter) WriteHeader(statusCode int) {
	m.statusCode = statusCode
}

func Test_jsonStore_Setup(t *testing.T) {
	t.Run("successful setup", func(t *testing.T) {
		s := newJSONStore()
		tmpDir := t.TempDir()

		jsonPath := path.Join(tmpDir, "store.json")
		if err := os.WriteFile(jsonPath, []byte("[]"), 0o644); err != nil {
			t.Fatalf("failed to create empty store.json: %v", err)
		}

		err := s.Setup(context.Background(), tmpDir)
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
	})

	t.Run("adds store.json if not exist", func(t *testing.T) {
		s := newJSONStore()
		tmpDir := t.TempDir()
		jsonPath := path.Join(tmpDir, "store.json")

		// Ensure store.json does not exist before Setup
		if _, err := os.Stat(jsonPath); !os.IsNotExist(err) {
			t.Fatalf("store.json already exists before test")
		}

		err := s.Setup(context.Background(), tmpDir)
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}

		// Now store.json should exist
		if _, err := os.Stat(jsonPath); err != nil {
			t.Fatalf("store.json not created by Setup: %v", err)
		}
	})

	t.Run("loads items from json, using id as key", func(t *testing.T) {
		s := newJSONStore()
		tmpDir := t.TempDir()

		key := "an-id"
		want := model.Item{Name: "a", ID: key}
		wantList := []model.Item{want}
		wantBytes, err := json.Marshal(wantList)
		if err != nil {
			t.Fatalf("failed to marshal want: %v", err)
		}

		jsonPath := path.Join(tmpDir, "store.json")
		if errW := os.WriteFile(jsonPath, wantBytes, 0o644); errW != nil {
			t.Fatalf("failed to create empty store.json: %v", errW)
		}

		err = s.Setup(context.Background(), tmpDir)
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
		got, exists := s.cache[key]
		if !exists {
			t.Fatal("expected item to exist")
		}

		if !reflect.DeepEqual(want, got) {
			t.Fatalf("expected: %+v, to be: %+v", got, want)
		}
	})

	testboil.ReturnsOnContextCancel(t, func(ctx context.Context) {
		s := newJSONStore()
		err := s.Setup(context.Background(), t.TempDir())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
	}, time.Millisecond*100)
}

func Test_jsonStore_Store(t *testing.T) {
	t.Run("store item successfully", func(t *testing.T) {
		s := newJSONStore()

		err := s.Setup(context.Background(), t.TempDir())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}

		item := model.Item{Name: "sample", ID: "1234"}
		err = s.Store(item)
		if err != nil {
			t.Fatalf("Store failed: %v", err)
		}

		got, exists := s.cache[item.ID]
		if !exists {
			t.Fatal("expected item to be stored but it does not exist")
		}
		if !reflect.DeepEqual(item, got) {
			t.Fatalf("expected: %+v, got: %+v", item, got)
		}
	})

	// This test is to ensure that the path of some media is updated while
	// the rest of the data is kept, as this is generated by LLM
	t.Run("update path on item without ID, keep the rest", func(t *testing.T) {
		s := newJSONStore()
		err := s.Setup(context.Background(), t.TempDir())
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
		pre := testboil.CreateTestFile(t, "before")
		post := testboil.CreateTestFile(t, "after")
		t.Cleanup(func() {
			pre.Close()
			post.Close()
		})
		largeIshString := ""
		for range 10 {
			largeIshString += "AABBCCDDEEFFGGAABBCCDDEEFFGGAABBCCDDEEFFGG"
		}
		// Same content in both files, implying it has been moved
		pre.WriteString(largeIshString)
		post.WriteString(largeIshString)
		want := "This should stay"
		has := model.Item{Name: "with_ID", Path: pre.Name(), Metadata: want}
		id := generateID(has)
		has.ID = id
		s.cache[id] = has

		newItemWithNoID := has
		newItemWithNoID.ID = ""
		newItemWithNoID.Path = post.Name()
		// Test should fail if this is overwritten
		newItemWithNoID.Metadata = ""
		err = s.Store(newItemWithNoID)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		got := s.cache[id].Metadata.(string)
		testboil.FailTestIfDiff(t, got, want)
	})
}

func Test_streamMkvToMp4(t *testing.T) {
	t.Run("successful mkv to mp4 stream", func(t *testing.T) {
		if _, err := exec.LookPath("ffmpeg"); err != nil {
			t.Skip("ffmpeg binary not found")
		}

		// Prepare test file path
		mkvPath := "mock/Jellyfish_1080_10s_1MB.mkv"
		if _, err := os.Stat(mkvPath); err != nil {
			t.Fatalf("test mkv file missing: %v", err)
		}

		req := mockHTTPRequest("GET", "/test", nil)
		r := req

		rec := newMockResponseWriter()

		streamMkvToMp4(rec, r, mkvPath)

		// Verify headers
		if rec.Header().Get("Content-Type") != "video/mp4" {
			t.Errorf("Content-Type not set: %s", rec.Header().Get("Content-Type"))
		}
		if rec.Header().Get("Accept-Ranges") != "bytes" {
			t.Errorf("Accept-Ranges not set")
		}
		if rec.Header().Get("Cache-Control") != "no-cache" {
			t.Errorf("Cache-Control not set")
		}
		// Output MP4 check (ftyp tag near file start)
		out := rec.buffer
		if len(out) < 12 || string(out[4:8]) != "ftyp" {
			t.Errorf("output not mp4 format")
		}
		if rec.statusCode != 200 && rec.statusCode != 0 {
			t.Errorf("unexpected http status: %d", rec.statusCode)
		}
	})

	t.Run("missing ffmpeg returns error", func(t *testing.T) {
		origLookPath := ffmpegLookPath
		ffmpegLookPath = "non-existent"
		t.Cleanup(func() {
			ffmpegLookPath = origLookPath
		})
		req := mockHTTPRequest("GET", "/test", nil)
		rec := newMockResponseWriter()
		streamMkvToMp4(rec, req, "mock/Jellyfish_1080_10s_1MB.mkv")
		if rec.statusCode != 500 {
			t.Errorf("expected 500 when ffmpeg is missing")
		}
		if !strings.Contains(string(rec.buffer), "ffmpeg must be installed") {
			t.Errorf("missing ffmpeg error response not found")
		}
	})

	t.Run("bad mkv path triggers error", func(t *testing.T) {
		req := mockHTTPRequest("GET", "/test", nil)
		rec := newMockResponseWriter()
		streamMkvToMp4(rec, req, "mock/doesnotexist.mkv")
		if rec.statusCode != 500 {
			t.Errorf("expected http status 500 for bad mkv input")
		}
	})

	t.Run("context cancel simulates disconnect", func(t *testing.T) {
		mkvPath := "mock/Jellyfish_1080_10s_1MB.mkv"
		req := mockHTTPRequest("GET", "/test", nil)
		ctx, cancel := context.WithCancel(req.Context())
		req = req.WithContext(ctx)
		rec := newMockResponseWriter()
		done := make(chan struct{})
		go func() {
			streamMkvToMp4(rec, req, mkvPath)
			close(done)
		}()
		cancel()
		select {
		case <-done:
		case <-time.After(time.Second):
			t.Errorf("timed out waiting for disconnect simulation")
		}
	})
}

func Test_jsonStore_ListHandlerFunc(t *testing.T) {
	jStore := &jsonStore{
		cache: map[string]model.Item{
			"1": {ID: "1", Name: "foo"},
			"2": {ID: "2", Name: "bar"},
		},
	}

	t.Run("returns all items as JSON", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rr := httptest.NewRecorder()

		handler := jStore.ListHandlerFunc()
		handler.ServeHTTP(rr, req)

		if ct := rr.Header().Get("Content-Type"); ct != "application/json" {
			t.Errorf("got Content-Type %q, want application/json", ct)
		}
		var items []model.Item
		if err := json.NewDecoder(rr.Body).Decode(&items); err != nil {
			t.Fatalf("failed decoding response: %v", err)
		}
		if len(items) != 2 {
			t.Errorf("expected 2 items, got %d", len(items))
		}
	})

	t.Run("cache nil triggers error", func(t *testing.T) {
		js := &jsonStore{}
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rr := httptest.NewRecorder()
		handler := js.ListHandlerFunc()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusInternalServerError {
			t.Errorf("expected internal error on nil cache")
		}
		if !strings.Contains(rr.Body.String(), "store not initialized") {
			t.Errorf("error message not reported")
		}
	})
}

func Test_jsonStore_VideoHandlerFunc(t *testing.T) {
	js := &jsonStore{}
	handler := js.VideoHandlerFunc()

	t.Run("cache nil triggers not found", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/video/1", nil)
		req.SetPathValue("id", "1")
		rr := httptest.NewRecorder()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusNotFound &&
			rr.Result().StatusCode != http.StatusInternalServerError {
			t.Errorf("expected 404 or 500 on nil cache")
		}
	})

	t.Run("missing id returns bad request", func(t *testing.T) {
		js.cache = map[string]model.Item{}
		req := httptest.NewRequest(http.MethodGet, "/video", nil)
		rr := httptest.NewRecorder()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusBadRequest {
			t.Errorf("want 400, got %d", rr.Result().StatusCode)
		}
	})

	t.Run("it should return 404 if item is found, but its not of video mimetype", func(t *testing.T) {
		js.cache = map[string]model.Item{
			"without_video_mime": {
				MIMEType: "something/else",
				Path:     "mock/Jellyfish_1080_10s_1MB.mkv",
			},
			"with_video_mime": {
				MIMEType: "video/webm",
				Path:     "mock/Jellyfish_1080_10s_1MB.mkv",
			},
		}
		req := httptest.NewRequest(http.MethodGet, "/video/with_video_mime", nil)
		req.SetPathValue("id", "with_video_mime")
		rr := httptest.NewRecorder()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusOK {
			t.Errorf("want 200 on video with mime, got %d", rr.Result().StatusCode)
		}
		req = httptest.NewRequest(http.MethodGet, "/video/without_video_mime", nil)
		req.SetPathValue("id", "without_video_mime")
		rr = httptest.NewRecorder()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusNotFound {
			t.Errorf("want 404 on video without mimetype, got %d", rr.Result().StatusCode)
		}
	})

	t.Run("unknown id returns 404", func(t *testing.T) {
		js.cache = map[string]model.Item{}
		req := httptest.NewRequest(http.MethodGet, "/video/xyz", nil)
		req.SetPathValue("id", "xyz")
		rr := httptest.NewRecorder()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusNotFound {
			t.Errorf("want 404, got %d", rr.Result().StatusCode)
		}
	})

	t.Run("known id, file not found", func(t *testing.T) {
		js.cache = map[string]model.Item{"x": {Path: "no/such/file", MIMEType: "image/png", Name: "img.png"}}
		req := httptest.NewRequest(http.MethodGet, "/video/x", nil)
		req.SetPathValue("id", "x")
		rr := httptest.NewRecorder()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusNotFound {
			t.Errorf("want 404 for missing file, got %d", rr.Result().StatusCode)
		}
	})

	t.Run("exists in cache, path not found", func(t *testing.T) {
		s := newJSONStore()
		tmpDir := t.TempDir()
		err := s.Setup(context.Background(), tmpDir)
		if err != nil {
			t.Fatalf("Setup failed: %v", err)
		}
		item := model.Item{
			Name:     "cacheonly",
			ID:       "cache-test-id",
			Path:     path.Join(tmpDir, "not-a-real-file.txt"),
			MIMEType: "video/plain",
		}
		s.cache[item.ID] = item

		req := mockHTTPRequest("GET", "/video/"+item.ID, nil)
		req.SetPathValue("id", item.ID)

		rec := newMockResponseWriter()
		handler := s.VideoHandlerFunc()
		handler(rec, req)
		if rec.statusCode != http.StatusNotFound {
			t.Fatalf("Expected status 404, got %d", rec.statusCode)
		}
		if !strings.Contains(string(rec.buffer), "") {
			t.Errorf("Expected error response, got: %s", rec.buffer)
		}
	})
}

type mockExtractor struct{}

func (m *mockExtractor) extract(item model.Item, streamIndex string) (string, error) {
	return "", fmt.Errorf("mocked failure")
}

func Test_jsonStore_SubsHandlerFunc(t *testing.T) {
	js := newJSONStore()

	t.Run("cache nil triggers not found", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/subs/1/0", nil)
		req.SetPathValue("vid", "1")
		req.SetPathValue("sub_idx", "0")
		rr := httptest.NewRecorder()
		handler := js.SubsHandlerFunc()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusNotFound {
			t.Errorf("expected 404 on nil cache, got %d", rr.Result().StatusCode)
		}
	})

	t.Run("missing video ID returns bad request", func(t *testing.T) {
		js.cache = map[string]model.Item{}
		req := httptest.NewRequest(http.MethodGet, "/subs", nil)
		rr := httptest.NewRecorder()
		handler := js.SubsHandlerFunc()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusBadRequest {
			t.Errorf("expected 400, got %d", rr.Result().StatusCode)
		}
	})

	t.Run("respond with 500 on extract failure", func(t *testing.T) {
		js := newJSONStore()
		js.cache = map[string]model.Item{"1": {ID: "1", Path: "dummy"}}

		js.subStreamExtractor = &mockExtractor{}
		req := httptest.NewRequest(http.MethodGet, "/subs/1/0", nil)
		req.SetPathValue("vid", "1")
		req.SetPathValue("sub_idx", "0")
		rr := httptest.NewRecorder()
		handler := js.SubsHandlerFunc()
		handler.ServeHTTP(rr, req)
		if rr.Result().StatusCode != http.StatusInternalServerError {
			t.Errorf("expected 500 on extractor fail, got %d", rr.Result().StatusCode)
		}
	})
}

func Test_Stream_jsonStore_ffmpegSubsUtil_extract(t *testing.T) {
	t.Run("extract subs if possible", func(t *testing.T) {
		subsUtil := ffmpegSubsUtil{}
		given := model.Item{
			ID:   "some_ID",
			Path: "./mock/Jellyfish_with_subs.mkv",
		}
		gotFile, err := subsUtil.extract(given, "1")
		if err != nil {
			t.Fatalf("failed to extract: %v", err)
		}

		gotData, err := os.ReadFile(gotFile)
		if err != nil {
			t.Fatalf("failed to read gotFile: %v", err)
		}
		// Subtitle line which appears in mock video
		testboil.AssertStringContains(t, string(gotData), "Pay close attention to each step.")
	})

	t.Run("it should error if ffmpeg is not installed", func(t *testing.T) {
		subsUtil := &ffmpegSubsUtil{}
		origPath := os.Getenv("PATH")
		defer os.Setenv("PATH", origPath)
		os.Setenv("PATH", "/nonexistent")
		item := model.Item{ID: "no-ffmpeg", Path: "/tmp/doesnotmatter.mkv"}
		_, err := subsUtil.extract(item, "0")
		if err == nil {
			t.Fatal("expected error when ffprobe unavailable, got nil")
		}
	})
}

func Test_Stream_jsonStore_ffmpegSubsUtil_find(t *testing.T) {
	t.Run("find uses mediaCache hit", func(t *testing.T) {
		wantIdx := 404
		util := &ffmpegSubsUtil{
			mediaCache: map[string]MediaInfo{
				"cache-id": {[]Stream{{Index: wantIdx}}},
			},
		}
		item := model.Item{ID: "cache-id", Path: "/tmp/some.mkv"}
		info, err := util.find(item)
		if err != nil {
			t.Fatalf("expected nil error, got %v", err)
		}
		if len(info.Streams) < 1 || info.Streams[0].Index != wantIdx {
			t.Fatalf("unexpected info: %+v", info)
		}
	})

	t.Run("find returns error when ffprobe/ffmpeg unavailable", func(t *testing.T) {
		util := &ffmpegSubsUtil{mediaCache: map[string]MediaInfo{}}
		origPath := os.Getenv("PATH")
		defer os.Setenv("PATH", origPath)
		os.Setenv("PATH", "/nonexistent")
		item := model.Item{ID: "missing-ff", Path: "/tmp/irrelevant.mkv"}
		_, err := util.find(item)
		if err == nil {
			t.Fatal("expected error when ffmpeg is unavailable, got nil")
		}
	})

	t.Run("find returns error for invalid input", func(t *testing.T) {
		util := &ffmpegSubsUtil{mediaCache: map[string]MediaInfo{}}
		item := model.Item{ID: "bogus", Path: "/path/does/not/exist.mkv"}
		_, err := util.find(item)
		if err == nil {
			t.Fatal("expected error for invalid input, got nil")
		}
	})

	t.Run("find caches on successful find", func(t *testing.T) {
		util := &ffmpegSubsUtil{
			mediaCache: map[string]MediaInfo{},
		}
		// Use a known good file with ffprobe available in path
		item := model.Item{ID: "some-unique-id", Path: "./mock/Jellyfish_with_subs.mkv"}
		_, err := util.find(item)
		if err != nil {
			t.Fatalf("unexpected error calling find: %v", err)
		}
		// Should set cache for this ID
		if _, ok := util.mediaCache[item.ID]; !ok {
			t.Fatalf("expected find to cache result for %s", item.ID)
		}
	})
}

func Test_Stream_jsonStore_ffmpegSubsUtil_cache(t *testing.T) {
	t.Run("it should return item on media cache hit", func(t *testing.T) {
		wantIdx := 1337
		// Setup ffmpegSubsUtil with mock caches
		util := &ffmpegSubsUtil{
			mediaCache: map[string]MediaInfo{
				"id-abc": {[]Stream{
					{
						Index: wantIdx,
					},
				}},
			},
			subsCache: map[string]string{
				"id-xyz": "/tmp/mocksubs.vtt",
			},
		}

		item := model.Item{ID: "id-abc", Path: "/tmp/mockfile.mkv"}
		// Should hit mediaCache and return without error
		info, err := util.find(item)
		if err != nil {
			t.Fatalf("expected nil error, got %v", err)
		}
		if info.Streams[0].Index != wantIdx {
			t.Fatalf("unexpected info from mediaCache: %+v", info)
		}

		item.ID = "id-xyz"
		got, err := util.extract(item, "0")
		if err != nil {
			t.Fatalf("expected nil err from extract cache, got %v", err)
		}
		if got != "/tmp/mocksubs.vtt" {
			t.Fatalf("unexpected path from subsCache: %s", got)
		}
	})

	t.Run("error on ffmpeg error (not panic)", func(t *testing.T) {
		util := &ffmpegSubsUtil{
			mediaCache: map[string]MediaInfo{},
			subsCache:  map[string]string{},
		}

		item := model.Item{ID: "nohit-" + randString(6), Path: os.DevNull}
		// Funky streamIndex but ffmpeg will fail, so expect error not panics
		_, err := util.extract(item, "0")
		if err == nil {
			t.Fatalf("expected error due to ffmpeg fail")
		}
	})
}

// randString for ID, deterministic length, not crypto-rand.
func randString(n int) string {
	letters := []rune("abcdefghijklmnopqrstuvwxyz")
	out := make([]rune, n)
	for i := range out {
		out[i] = letters[i%len(letters)]
	}
	return string(out)
}
